{"version":3,"sources":["webpack://bpd-toolkit/webpack/universalModuleDefinition","webpack://bpd-toolkit/webpack/bootstrap","webpack://bpd-toolkit/./src/helpers/errors.ts","webpack://bpd-toolkit/./src/helpers/functions.ts","webpack://bpd-toolkit/./src/subscriptions/subscriptions.ts","webpack://bpd-toolkit/./src/worker/worker.ts","webpack://bpd-toolkit/./src/state/state.ts","webpack://bpd-toolkit/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ErrorBase","Error","message","super","setPrototypeOf","this","IncorrectDataError","WorkerNotReadyError","CreateStateError","InitStateError","CommonError","type","StateManagerShorthandError","is","obj","Array","isArray","length","id","idx","counter","undefined","callback","options","subscriber","createSubscriber","push","subscribtionId","index","findIndex","subscirber","splice","state","toRemove","forEach","sub","singleRun","e","unsubscribe","generateId","next","action","isInQueue","run","current","shift","then","catch","data","init","performer","config","onUpdate","onWorkerChange","onPerform","onWorkerPerform","onError","onWorkerError","onSubscriberError","reportError","subscribe","perform","includes","notify","result","reportChange","Promise","resolve","detail","onChange","VERSION_INFO","initialValue","executeIfValid","resultState","methodName","createStateManager","$bdpStateManager","createState","removeState","getState"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpd-toolkit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpd-toolkit\"] = factory();\n\telse\n\t\troot[\"bpd-toolkit\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export class ErrorBase extends Error {\r\n    constructor(name: string, message?: string,) {\r\n        super(message);\r\n        Object.setPrototypeOf(this, new.target.prototype);\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport class IncorrectDataError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"IncorrectDataError\", message)\r\n    }\r\n}\r\n\r\nexport class WorkerNotReadyError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"WorkerNotReadyError\", message);\r\n    }\r\n}\r\n\r\nexport class PerformerError extends ErrorBase {\r\n    constructor(base: Error) {\r\n        super(\"PerformerError:\" + base.name, base.message);\r\n        this.stack = base.stack;\r\n    }\r\n}\r\n\r\nexport class CreateStateError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"CreateStateError\", message);\r\n    }\r\n}\r\n\r\nexport class InitStateError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"InitStateError\", message);\r\n    }\r\n}\r\n\r\nexport class CommonError extends ErrorBase {\r\n    constructor(type: string, message?: string) {\r\n        super(type, message);\r\n    }\r\n}\r\n\r\nexport class StateManagerShorthandError extends ErrorBase {\r\n    constructor(type: string, message?: string) {\r\n        super(\"StateManagerShorthandError\", type + \":\" + message);\r\n    }\r\n}","export function is(obj: any) {\r\n    if (typeof obj === 'undefined' || obj === null) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(obj) && obj.length === 0) {\r\n        return false;\r\n    }\r\n    if (typeof obj === 'string' && obj.length === 0) {\r\n        false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function* counter() {\r\n    let idx = 0;\r\n    while (true) {\r\n        let reset = yield idx++;\r\n        if (reset || idx > 200000) {\r\n            idx = 0\r\n        }\r\n    }\r\n}","import { IncorrectDataError } from \"../helpers/errors\";\r\nimport { counter, is } from \"../helpers/functions\";\r\n\r\nexport interface Subscriber<VState> {\r\n    id: string,\r\n    options?: SubscriberOptions;\r\n    callback: (state: VState) => void;\r\n}\r\n\r\nexport interface SubscriberOptions {\r\n    singleRun: boolean;\r\n}\r\n\r\ninterface ErrorCallback {\r\n    (e: Error): void;\r\n}\r\n\r\nexport interface ISubscriptionsManager<VState> {\r\n    onError(callback: (e: Error) => void): void;\r\n    subscribe(callback: (state: VState) => void, options?: SubscriberOptions): string;\r\n    unsubscribe(subscribtionId: string): void;\r\n    notify(state: VState): Promise<boolean>;\r\n    getSubscribers(): Subscriber<VState>[];\r\n}\r\n\r\nexport class SubscriptionsManager<VState> implements ISubscriptionsManager<VState>{\r\n    #subscribers: Subscriber<VState>[];\r\n    #onError: ErrorCallback | undefined;\r\n    #counter: Generator<number, void, unknown>;\r\n    #id: string;\r\n    constructor(id: string) {\r\n        if (!is(id)) {\r\n            throw new IncorrectDataError(\"Valid Id is required\");\r\n        }\r\n        this.#subscribers = [];\r\n        this.#id = id;\r\n        this.#counter = counter();\r\n        this.#onError = undefined;\r\n    }\r\n\r\n    subscribe(callback: (state: VState) => void, options?: SubscriberOptions): string {\r\n        let subscriber = this.createSubscriber(callback, options);\r\n        this.#subscribers.push(subscriber);\r\n        return subscriber.id;\r\n    }\r\n\r\n    unsubscribe(subscribtionId: string): void {\r\n        if (!is(subscribtionId)) {\r\n            return;\r\n        }\r\n        let index = this.#subscribers.findIndex((subscirber: Subscriber<VState>) => {\r\n            return subscirber.id === subscribtionId;\r\n        })\r\n        if (index < 0) {\r\n            return;\r\n        }\r\n        this.#subscribers.splice(index, 1);\r\n    }\r\n\r\n    async notify(state: VState): Promise<boolean> {\r\n        let toRemove: string[] = []\r\n        this.#subscribers.forEach(sub => {\r\n            if (sub.options && sub.options.singleRun) {\r\n                toRemove.push(sub.id);\r\n            }\r\n            try {\r\n                sub.callback(state);\r\n            } catch (e) {\r\n                toRemove.push(sub.id);\r\n                if (this.#onError) {\r\n                    this.#onError(e);\r\n                }\r\n            }\r\n        })\r\n        toRemove.forEach(id => this.unsubscribe(id));\r\n        return true;\r\n    }\r\n\r\n    onError(callback: (e: Error) => void) {\r\n        this.#onError = callback;\r\n    }\r\n\r\n    getSubscribers(): Subscriber<VState>[] {\r\n        return [...this.#subscribers];\r\n    }\r\n\r\n    private createSubscriber(callback: (state: VState) => void, options?: SubscriberOptions): Subscriber<VState> {\r\n        return {\r\n            id: this.generateId(),\r\n            options: options,\r\n            callback: callback\r\n        }\r\n    }\r\n\r\n    private generateId(): string {\r\n        return `${this.#id}:${this.#counter.next().value}`;\r\n    }\r\n}","import { IncorrectDataError, WorkerNotReadyError } from \"../helpers/errors\";\r\nimport { is } from \"../helpers/functions\";\r\nimport { BpdStateAction } from \"../interfaces\";\r\n\r\nexport interface OnPerformCallback<V, P> {\r\n    (action: BpdStateAction<V>): Promise<P>;\r\n}\r\n\r\nexport interface OnUpdateCallback<V, P> {\r\n    (result: P, action?: BpdStateAction<V>): void;\r\n}\r\n\r\nexport interface OnErrorCallback<V> {\r\n    (error: Error, action?: BpdStateAction<V>): void;\r\n}\r\n\r\nexport interface IBpdStateWorker<V, P> {\r\n    perform(action: BpdStateAction<V>): void\r\n    onPerform(callback: OnPerformCallback<V, P>): void;\r\n    onUpdate(callback: OnUpdateCallback<V, P>): void;\r\n    onError(callback: OnErrorCallback<V>): void;\r\n}\r\n\r\nexport class BpdStateWorker<V, P> implements IBpdStateWorker<V, P> {\r\n    #queue: BpdStateAction<V>[];\r\n    #queuelock: boolean;\r\n    #lock: boolean;\r\n    #callback: OnPerformCallback<V, P> | undefined;\r\n    #onUpdate: OnUpdateCallback<V, P> | undefined;\r\n    #onError: OnErrorCallback<V> | undefined;\r\n    constructor() {\r\n        this.#queue = [];\r\n        this.#lock = false;\r\n        this.#queuelock = false;\r\n        this.#onError = undefined;\r\n        this.#callback = undefined;\r\n        this.#onUpdate = undefined;\r\n\r\n    }\r\n\r\n    onPerform(callback: OnPerformCallback<V, P>) {\r\n        this.#callback = callback;\r\n    }\r\n\r\n    onUpdate(callback: OnUpdateCallback<V, P>) {\r\n        this.#onUpdate = callback;\r\n    }\r\n\r\n    onError(callback: OnErrorCallback<V>) {\r\n        this.#onError = callback;\r\n    }\r\n\r\n    perform(action: BpdStateAction<V>) {\r\n        if (!is(action)) {\r\n            throw new IncorrectDataError(\"Inproper action object passed to worker\")\r\n        }\r\n        if (!is(this.#callback) || !is(this.#onUpdate)) {\r\n            throw new WorkerNotReadyError(\"Callbacks are not set\");\r\n        }\r\n        if (!this.isInQueue(action)) {\r\n            this.#queue.push(action);\r\n        }\r\n        this.run();\r\n    }\r\n\r\n    private run() {\r\n        if (this.#queuelock || this.#lock || !is(this.#queue)) {\r\n            return;\r\n        }\r\n        this.#lock = true;\r\n        let current = this.#queue.shift();\r\n        if (!current) {\r\n            this.#lock = false;\r\n            this.run();\r\n        }\r\n        if (this.#callback && current) {\r\n            this.#callback(current).then((state: P) => {\r\n                if (this.#onUpdate) {\r\n                    this.#onUpdate(state, current);\r\n                }\r\n                this.#lock = false;\r\n                this.run();\r\n            }).catch(e => {\r\n                if (this.#onError) {\r\n                    this.#onError(e, current);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private isInQueue(action: BpdStateAction<V>) {\r\n        this.#queuelock = true;\r\n        let index = this.#queue.findIndex(value => {\r\n            return action.action === value.action && value.data === action.data;\r\n        })\r\n        this.#queuelock = false;\r\n        return index > -1;\r\n    }\r\n}","import { InitStateError, IncorrectDataError } from \"../helpers/errors\";\r\nimport { is } from \"../helpers/functions\";\r\nimport { BpdStateAction, BpdStateManagerConfig, OnChangeEventType, StatePerformer } from \"../interfaces\";\r\nimport { ISubscriptionsManager, SubscriptionsManager } from \"../subscriptions/subscriptions\";\r\nimport { IBpdStateWorker, BpdStateWorker } from \"../worker/worker\";\r\n\r\nexport interface IBpdState<VState, PAction> {\r\n    perform(action: BpdStateAction<PAction>, callback?: (state: VState) => void | undefined): void;\r\n    subscribe(callback: (state: VState) => void): string | undefined;\r\n    unsubscribe(id: string): boolean;\r\n    getState(): VState;\r\n}\r\n\r\nexport class BpdState<VState, PAction> implements IBpdState<VState, PAction> {\r\n    #state: VState;\r\n    #id: string;\r\n    #config: BpdStateManagerConfig<VState>;\r\n    #worker: IBpdStateWorker<PAction, VState>;\r\n    #performer: StatePerformer<PAction, VState>;\r\n    #subscriptionManager: ISubscriptionsManager<VState>;\r\n\r\n    constructor(id: string, init: VState, performer: StatePerformer<PAction, VState>, config?: BpdStateManagerConfig<VState>) {\r\n        if (!is(id)) {\r\n            throw new InitStateError(\"State id must be provided\")\r\n        }\r\n        if (!is(init)) {\r\n            throw new InitStateError(\"Initial value must be a valid, initialized object\")\r\n        }\r\n        if (!is(performer)) {\r\n            throw new InitStateError(\"Perfromer callback was not provided\")\r\n        }\r\n        this.#id = id;\r\n        this.#state = init;\r\n        this.#config = config ?? {};\r\n        this.#performer = performer;\r\n        this.#worker = new BpdStateWorker<PAction, VState>();\r\n        this.#worker.onUpdate(this.onWorkerChange.bind(this))\r\n        this.#worker.onPerform(this.onWorkerPerform.bind(this));\r\n        this.#worker.onError(this.onWorkerError.bind(this));\r\n        this.#subscriptionManager = new SubscriptionsManager(this.#id);\r\n        this.#subscriptionManager.onError(this.onSubscriberError.bind(this));\r\n    }\r\n\r\n    perform(action: BpdStateAction<PAction>, callback?: (state: VState) => void) {\r\n        if (!is(action)) {\r\n            this.reportError(\"lib\", \"In proper action object\", new IncorrectDataError(\"In proper action object\"))\r\n        }\r\n        if (callback) {\r\n            this.#subscriptionManager.subscribe(callback, {\r\n                singleRun: true\r\n            })\r\n        }\r\n        this.#worker.perform(action);\r\n    }\r\n\r\n    subscribe(callback: (state: VState) => void): string | undefined {\r\n        if (!is(callback)) {\r\n            this.reportError(\"lib\", \"\", new IncorrectDataError(\"Callback has not been set\"))\r\n            return undefined;\r\n        }\r\n        return this.#subscriptionManager.subscribe(callback)\r\n    }\r\n\r\n    unsubscribe(id: string): boolean {\r\n        if (!is(id)) {\r\n            return false;\r\n        }\r\n        this.#subscriptionManager.unsubscribe(id);\r\n        return true;\r\n    }\r\n\r\n    getState(): VState {\r\n        return this.#state;\r\n    }\r\n\r\n    private onWorkerChange(state: VState, action?: BpdStateAction<PAction>,) {\r\n        if (['number', 'string', 'boolean'].includes(typeof state) || Array.isArray(state)) {\r\n            this.#state = state;\r\n        } else {\r\n            this.#state = { ...state };\r\n        }\r\n        this.#subscriptionManager.notify(state)\r\n            .then((result) => {\r\n                this.reportChange('action', action ? action.action : \"\")\r\n            })\r\n            .catch(e => {\r\n                this.reportError(\"action\", action ? action.action : \"\", e)\r\n            })\r\n    }\r\n\r\n    private onWorkerPerform(action: BpdStateAction<PAction>) {\r\n        return new Promise<VState>((resolve) => {\r\n            resolve(this.#performer(this.#state, action));\r\n        })\r\n    }\r\n\r\n    private onWorkerError(e: Error, action?: BpdStateAction<PAction>): void {\r\n        this.reportError('action', action ? action.action : \"\", e);\r\n    }\r\n\r\n    private onSubscriberError(e: Error) {\r\n        this.reportError('lib', \"Subscribers error\", e);\r\n    }\r\n\r\n    private reportError(type: OnChangeEventType, detail: string, e: Error) {\r\n        if (this.#config && this.#config.onError) {\r\n            this.#config.onError(this.#id, type, e, detail)\r\n        }\r\n    }\r\n\r\n    private reportChange(type: OnChangeEventType, detail: string) {\r\n        if (this.#config && this.#config.onChange) {\r\n            this.#config.onChange(this.#id, type, detail, this.#state)\r\n        }\r\n    }\r\n\r\n}","import { CommonError, CreateStateError, StateManagerShorthandError } from \"./helpers/errors\";\r\nimport { is } from \"./helpers/functions\";\r\nimport { BpdStateManagerConfig, StatePerformer, BpdStateAction, BpdManagedStates } from \"./interfaces\";\r\nimport { BpdState, IBpdState } from \"./state/state\";\r\n\r\nexport const VERSION_INFO = \"0.1.0\";\r\ndeclare global {\r\n    interface Window {\r\n        $bdpStateManager: any;\r\n    }\r\n}\r\n\r\nexport class BpdStateManager<VStates, TActions> {\r\n    #config: BpdStateManagerConfig<VStates> | undefined;\r\n    #states: BpdManagedStates<VStates, TActions>;\r\n    constructor(config?: BpdStateManagerConfig<VStates>) {\r\n        this.#config = config;\r\n        this.#states = {};\r\n    }\r\n\r\n    createState(name: string, initialValue: VStates, performer: StatePerformer<TActions, VStates>, config?: BpdStateManagerConfig<VStates>) {\r\n        if (!is(name)) {\r\n            throw new CreateStateError(\"State name was not provided\");\r\n        }\r\n        this.#states[name] = new BpdState(name, initialValue, performer, config ?? this.#config);\r\n    }\r\n\r\n    removeState(name: string) {\r\n        this.executeIfValid(name, \"Perform\", (state) => {\r\n            delete this.#states[name];\r\n        })\r\n    }\r\n\r\n    getState(name: string): IBpdState<VStates, TActions> | undefined {\r\n        let resultState = undefined;\r\n        this.executeIfValid(name, \"Perform\", (state) => {\r\n            resultState = state;\r\n        })\r\n        return resultState;\r\n    }\r\n\r\n    perform(name: string, action: BpdStateAction<TActions>, callback?: (state: VStates) => void) {\r\n        this.executeIfValid(name, \"Perform\", (state) => {\r\n            state.perform(action, callback);\r\n        })\r\n    }\r\n\r\n    subscribe(name: string, callback: (state: VStates) => void): string | undefined {\r\n        let id = undefined;\r\n        this.executeIfValid(name, \"Subscribe\", (state) => {\r\n            id = state.subscribe(callback);\r\n        })\r\n        return id;\r\n    }\r\n\r\n    unsubscribe(name: string, id: string) {\r\n        this.executeIfValid(name, \"Unsubscribe\", (state) => {\r\n            state.unsubscribe(id);\r\n        })\r\n    }\r\n\r\n    private executeIfValid(name: string, methodName: string, callback: (state: IBpdState<VStates, TActions>) => void) {\r\n        if (!is(name)) {\r\n            throw new CommonError(methodName + \"Error\", \"State name is not provided\")\r\n        }\r\n        let state = this.#states[name];\r\n        if (!is(state)) {\r\n            throw new CommonError(methodName + \"StateError\", \"State not found\")\r\n        }\r\n        callback(state);\r\n    }\r\n}\r\n\r\n\r\nexport function createStateManager<VStates, TActions>(config?: BpdStateManagerConfig<VStates>): void {\r\n    window.$bdpStateManager = new BpdStateManager<VStates, TActions>(config);\r\n}\r\n\r\nexport function createState<VStates, TActions>(name: string, initialValue: VStates, performer: StatePerformer<TActions, VStates>, config?: BpdStateManagerConfig<VStates>): void {\r\n    if (!is(window.$bdpStateManager)) {\r\n        throw new StateManagerShorthandError(\"createState\", \"Manager must be initialized first with createStateManager\")\r\n    }\r\n    window.$bdpStateManager.createState(name, initialValue, performer, config);\r\n}\r\n\r\nexport function removeState<VStates, TActions>(name: string): void {\r\n    if (!is(window.$bdpStateManager)) {\r\n        throw new StateManagerShorthandError(\"removeState\", \"Manager must be initialized first with createStateManager\")\r\n    }\r\n    window.$bdpStateManager.removeState(name);\r\n}\r\n\r\nexport function getState<VStates, TActions>(name: string): IBpdState<VStates, TActions> {\r\n    if (!is(window.$bdpStateManager)) {\r\n        throw new StateManagerShorthandError(\"getState\", \"Manager must be initialized first with createStateManager\")\r\n    }\r\n    return window.$bdpStateManager.getState(name);\r\n}\r\n\r\nexport function perform<VStates, TActions>(name: string, action: BpdStateAction<TActions>, callback?: (state: VStates) => void) {\r\n    if (!is(window.$bdpStateManager)) {\r\n        throw new StateManagerShorthandError(\"perform\", \"Manager must be initialized first with createStateManager\")\r\n    }\r\n    window.$bdpStateManager.perform(name, action, callback);\r\n}\r\n\r\nexport function subscribe<VStates, TActions>(name: string, callback: (state: VStates) => void): string {\r\n    if (!is(window.$bdpStateManager)) {\r\n        throw new StateManagerShorthandError(\"subscribe\", \"Manager must be initialized first with createStateManager\")\r\n    }\r\n    return window.$bdpStateManager.subscribe(name, callback);\r\n}\r\n\r\nexport function unsubscribe<VStates, TActions>(name: string, id: string) {\r\n    if (!is(window.$bdpStateManager)) {\r\n        throw new StateManagerShorthandError(\"unsubscribe\", \"Manager must be initialized first with createStateManager\")\r\n    }\r\n    window.$bdpStateManager.unsubscribe(name, id);\r\n}\r\n\r\n"],"sourceRoot":""}