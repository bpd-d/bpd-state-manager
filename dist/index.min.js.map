{"version":3,"sources":["webpack://bpd-toolkit/webpack/universalModuleDefinition","webpack://bpd-toolkit/webpack/bootstrap","webpack://bpd-toolkit/./src/helpers/errors.ts","webpack://bpd-toolkit/./src/helpers/functions.ts","webpack://bpd-toolkit/./src/helpers/backup.ts","webpack://bpd-toolkit/./src/helpers/copy.ts","webpack://bpd-toolkit/./src/subscriptions/subscriptions.ts","webpack://bpd-toolkit/./src/worker/worker.ts","webpack://bpd-toolkit/./src/state/state.ts","webpack://bpd-toolkit/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ErrorBase","Error","message","super","setPrototypeOf","this","IncorrectDataError","WorkerNotReadyError","CreateStateError","InitStateError","CommonError","type","StateManagerShorthandError","is","obj","Array","isArray","length","StateBackup","v","shift","push","pop","ObjectCopyMaker","newOne","includes","id","idx","counter","undefined","callback","options","subscriber","createSubscriber","subscribtionId","index","findIndex","subscirber","splice","state","toRemove","forEach","sub","singleRun","e","unsubscribe","generateId","next","action","isInQueue","run","current","then","catch","data","init","performer","config","onUpdate","onWorkerChange","onPerform","onWorkerPerform","onError","onWorkerError","onSubscriberError","copyMaker","reportError","subscribe","perform","copy","assignStateAndNotify","Promise","resolve","lastValue","undo","detail","onChange","notify","result","reportChange","VERSION_INFO","initialValue","executeIfValid","resultState","methodName","$bdpStateManager","createState","removeState","getState"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpd-toolkit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpd-toolkit\"] = factory();\n\telse\n\t\troot[\"bpd-toolkit\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export class ErrorBase extends Error {\r\n    constructor(name: string, message?: string,) {\r\n        super(message);\r\n        Object.setPrototypeOf(this, new.target.prototype);\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport class IncorrectDataError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"IncorrectDataError\", message)\r\n    }\r\n}\r\n\r\nexport class WorkerNotReadyError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"WorkerNotReadyError\", message);\r\n    }\r\n}\r\n\r\nexport class PerformerError extends ErrorBase {\r\n    constructor(base: Error) {\r\n        super(\"PerformerError:\" + base.name, base.message);\r\n        this.stack = base.stack;\r\n    }\r\n}\r\n\r\nexport class CreateStateError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"CreateStateError\", message);\r\n    }\r\n}\r\n\r\nexport class InitStateError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"InitStateError\", message);\r\n    }\r\n}\r\n\r\nexport class CommonError extends ErrorBase {\r\n    constructor(type: string, message?: string) {\r\n        super(type, message);\r\n    }\r\n}\r\n\r\nexport class StateManagerShorthandError extends ErrorBase {\r\n    constructor(type: string, message?: string) {\r\n        super(\"StateManagerShorthandError\", type + \":\" + message);\r\n    }\r\n}","export function is(obj: any) {\r\n    if (typeof obj === 'undefined' || obj === null) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(obj) && obj.length === 0) {\r\n        return false;\r\n    }\r\n    if (typeof obj === 'string' && obj.length === 0) {\r\n        false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function* counter() {\r\n    let idx = 0;\r\n    while (true) {\r\n        let reset = yield idx++;\r\n        if (reset || idx > 200000) {\r\n            idx = 0\r\n        }\r\n    }\r\n}","export interface IStateBackup<VState> {\r\n    push(v: VState): void;\r\n    undo(): VState | undefined;\r\n}\r\n\r\nexport class StateBackup<VState> implements IStateBackup<VState> {\r\n    #states: VState[];\r\n    #maxCount: number;\r\n    constructor() {\r\n        this.#states = [];\r\n        this.#maxCount = 20\r\n    }\r\n    push(v: VState): void {\r\n        if (this.#states.length >= this.#maxCount) {\r\n            this.#states.shift();\r\n        }\r\n        this.#states.push(v);\r\n    }\r\n    undo(): VState | undefined {\r\n        if (this.#states.length > 0) {\r\n            return this.#states.pop();\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n}","import { IObjectCopyMaker } from \"../interfaces\";\r\n\r\nexport class ObjectCopyMaker<VState> implements IObjectCopyMaker<VState> {\r\n    copy(obj: VState): VState {\r\n        if (typeof obj === 'undefined' || obj === null) {\r\n            return obj;\r\n        }\r\n        let newOne: VState | null = null;\r\n        if (['number', 'string', 'boolean'].includes(typeof obj) || Array.isArray(obj)) {\r\n            newOne = obj;\r\n        } else {\r\n            newOne = { ...obj };\r\n        }\r\n        return newOne;\r\n    }\r\n\r\n}","import { IncorrectDataError } from \"../helpers/errors\";\r\nimport { counter, is } from \"../helpers/functions\";\r\n\r\nexport interface Subscriber<VState> {\r\n    id: string,\r\n    options?: SubscriberOptions;\r\n    callback: (state: VState) => void;\r\n}\r\n\r\nexport interface SubscriberOptions {\r\n    singleRun: boolean;\r\n}\r\n\r\ninterface ErrorCallback {\r\n    (e: Error): void;\r\n}\r\n\r\nexport interface ISubscriptionsManager<VState> {\r\n    onError(callback: (e: Error) => void): void;\r\n    subscribe(callback: (state: VState) => void, options?: SubscriberOptions): string;\r\n    unsubscribe(subscribtionId: string): void;\r\n    notify(state: VState): Promise<boolean>;\r\n    getSubscribers(): Subscriber<VState>[];\r\n}\r\n\r\nexport class SubscriptionsManager<VState> implements ISubscriptionsManager<VState>{\r\n    #subscribers: Subscriber<VState>[];\r\n    #onError: ErrorCallback | undefined;\r\n    #counter: Generator<number, void, unknown>;\r\n    #id: string;\r\n    constructor(id: string) {\r\n        if (!is(id)) {\r\n            throw new IncorrectDataError(\"Valid Id is required\");\r\n        }\r\n        this.#subscribers = [];\r\n        this.#id = id;\r\n        this.#counter = counter();\r\n        this.#onError = undefined;\r\n    }\r\n\r\n    subscribe(callback: (state: VState) => void, options?: SubscriberOptions): string {\r\n        let subscriber = this.createSubscriber(callback, options);\r\n        this.#subscribers.push(subscriber);\r\n        return subscriber.id;\r\n    }\r\n\r\n    unsubscribe(subscribtionId: string): void {\r\n        if (!is(subscribtionId)) {\r\n            return;\r\n        }\r\n        let index = this.#subscribers.findIndex((subscirber: Subscriber<VState>) => {\r\n            return subscirber.id === subscribtionId;\r\n        })\r\n        if (index < 0) {\r\n            return;\r\n        }\r\n        this.#subscribers.splice(index, 1);\r\n    }\r\n\r\n    async notify(state: VState): Promise<boolean> {\r\n        let toRemove: string[] = []\r\n        this.#subscribers.forEach(sub => {\r\n            if (sub.options && sub.options.singleRun) {\r\n                toRemove.push(sub.id);\r\n            }\r\n            try {\r\n                sub.callback(state);\r\n            } catch (e) {\r\n                toRemove.push(sub.id);\r\n                if (this.#onError) {\r\n                    this.#onError(e);\r\n                }\r\n            }\r\n        })\r\n        toRemove.forEach(id => this.unsubscribe(id));\r\n        return true;\r\n    }\r\n\r\n    onError(callback: (e: Error) => void) {\r\n        this.#onError = callback;\r\n    }\r\n\r\n    getSubscribers(): Subscriber<VState>[] {\r\n        return [...this.#subscribers];\r\n    }\r\n\r\n    private createSubscriber(callback: (state: VState) => void, options?: SubscriberOptions): Subscriber<VState> {\r\n        return {\r\n            id: this.generateId(),\r\n            options: options,\r\n            callback: callback\r\n        }\r\n    }\r\n\r\n    private generateId(): string {\r\n        return `${this.#id}:${this.#counter.next().value}`;\r\n    }\r\n}","import { IncorrectDataError, WorkerNotReadyError } from \"../helpers/errors\";\r\nimport { is } from \"../helpers/functions\";\r\nimport { BpdStateAction } from \"../interfaces\";\r\n\r\nexport interface OnPerformCallback<V, P> {\r\n    (action: BpdStateAction<V>): Promise<P>;\r\n}\r\n\r\nexport interface OnUpdateCallback<V, P> {\r\n    (result: P, action?: BpdStateAction<V>): void;\r\n}\r\n\r\nexport interface OnErrorCallback<V> {\r\n    (error: Error, action?: BpdStateAction<V>): void;\r\n}\r\n\r\nexport interface IBpdStateWorker<V, P> {\r\n    perform(action: BpdStateAction<V>): void\r\n    onPerform(callback: OnPerformCallback<V, P>): void;\r\n    onUpdate(callback: OnUpdateCallback<V, P>): void;\r\n    onError(callback: OnErrorCallback<V>): void;\r\n}\r\n\r\nexport class BpdStateWorker<V, P> implements IBpdStateWorker<V, P> {\r\n    #queue: BpdStateAction<V>[];\r\n    #queuelock: boolean;\r\n    #lock: boolean;\r\n    #onPerform: OnPerformCallback<V, P> | undefined;\r\n    #onUpdate: OnUpdateCallback<V, P> | undefined;\r\n    #onError: OnErrorCallback<V> | undefined;\r\n    constructor() {\r\n        this.#queue = [];\r\n        this.#lock = false;\r\n        this.#queuelock = false;\r\n        this.#onError = undefined;\r\n        this.#onPerform = undefined;\r\n        this.#onUpdate = undefined;\r\n\r\n    }\r\n\r\n    onPerform(callback: OnPerformCallback<V, P>) {\r\n        this.#onPerform = callback;\r\n    }\r\n\r\n    onUpdate(callback: OnUpdateCallback<V, P>) {\r\n        this.#onUpdate = callback;\r\n    }\r\n\r\n    onError(callback: OnErrorCallback<V>) {\r\n        this.#onError = callback;\r\n    }\r\n\r\n    perform(action: BpdStateAction<V>) {\r\n        if (!is(action)) {\r\n            throw new IncorrectDataError(\"Inproper action object passed to worker\")\r\n        }\r\n        if (!is(this.#onPerform) || !is(this.#onUpdate)) {\r\n            throw new WorkerNotReadyError(\"Callbacks are not set\");\r\n        }\r\n        if (!this.isInQueue(action)) {\r\n            this.#queue.push(action);\r\n        }\r\n        this.run();\r\n    }\r\n\r\n    private run() {\r\n        if (this.#queuelock || this.#lock || !is(this.#queue)) {\r\n            return;\r\n        }\r\n        this.#lock = true;\r\n        let current = this.#queue.shift();\r\n        if (!current) {\r\n            this.#lock = false;\r\n            this.run();\r\n        }\r\n        if (this.#onPerform && current) {\r\n            this.#onPerform(current).then((state: P) => {\r\n                if (this.#onUpdate) {\r\n                    this.#onUpdate(state, current);\r\n                }\r\n                this.#lock = false;\r\n                this.run();\r\n            }).catch(e => {\r\n                if (this.#onError) {\r\n                    this.#onError(e, current);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private isInQueue(action: BpdStateAction<V>) {\r\n        this.#queuelock = true;\r\n        let index = this.#queue.findIndex(value => {\r\n            return action.action === value.action && value.data === action.data;\r\n        })\r\n        this.#queuelock = false;\r\n        return index > -1;\r\n    }\r\n}","import { IStateBackup, StateBackup } from \"../helpers/backup\";\r\nimport { ObjectCopyMaker } from \"../helpers/copy\";\r\nimport { InitStateError, IncorrectDataError } from \"../helpers/errors\";\r\nimport { is } from \"../helpers/functions\";\r\nimport { BpdStateAction, BpdStateManagerConfig, IObjectCopyMaker, OnChangeEventType, StatePerformer } from \"../interfaces\";\r\nimport { ISubscriptionsManager, SubscriptionsManager } from \"../subscriptions/subscriptions\";\r\nimport { IBpdStateWorker, BpdStateWorker } from \"../worker/worker\";\r\nconst UNDO_ACTION_NAME = \"$$UNDO_FROM_BACKUP\";\r\nexport interface IBpdState<VState, PAction> {\r\n    perform(action: BpdStateAction<PAction>, callback?: (state: VState) => void | undefined): void;\r\n    subscribe(callback: (state: VState) => void): string | undefined;\r\n    unsubscribe(id: string): boolean;\r\n    getState(): VState;\r\n    undo(): void;\r\n}\r\n\r\nexport class BpdState<VState, PAction> implements IBpdState<VState, PAction> {\r\n    #state: VState;\r\n    #backup: IStateBackup<VState>;\r\n    #id: string;\r\n    #config: BpdStateManagerConfig<VState>;\r\n    #worker: IBpdStateWorker<PAction, VState>;\r\n    #performer: StatePerformer<PAction, VState>;\r\n    #subscriptionManager: ISubscriptionsManager<VState>;\r\n    #copyMaker: IObjectCopyMaker<VState>;\r\n\r\n    constructor(id: string, init: VState, performer: StatePerformer<PAction, VState>, config?: BpdStateManagerConfig<VState>) {\r\n        if (!is(id)) {\r\n            throw new InitStateError(\"State id must be provided\")\r\n        }\r\n        if (!is(init)) {\r\n            throw new InitStateError(\"Initial value must be a valid, initialized object\")\r\n        }\r\n        if (!is(performer)) {\r\n            throw new InitStateError(\"Perfromer callback was not provided\")\r\n        }\r\n        this.#id = id;\r\n        this.#state = init;\r\n        this.#config = config ?? {};\r\n        this.#performer = performer;\r\n        this.#worker = new BpdStateWorker<PAction, VState>();\r\n        this.#worker.onUpdate(this.onWorkerChange.bind(this))\r\n        this.#worker.onPerform(this.onWorkerPerform.bind(this));\r\n        this.#worker.onError(this.onWorkerError.bind(this));\r\n        this.#subscriptionManager = new SubscriptionsManager(this.#id);\r\n        this.#subscriptionManager.onError(this.onSubscriberError.bind(this));\r\n        this.#copyMaker = this.#config.copyMaker ?? new ObjectCopyMaker();\r\n        this.#backup = new StateBackup();\r\n    }\r\n\r\n    perform(action: BpdStateAction<PAction>, callback?: (state: VState) => void) {\r\n        if (!is(action)) {\r\n            this.reportError(\"lib\", \"In proper action object\", new IncorrectDataError(\"In proper action object\"))\r\n        }\r\n        if (callback) {\r\n            this.#subscriptionManager.subscribe(callback, {\r\n                singleRun: true\r\n            })\r\n        }\r\n        this.#worker.perform(action);\r\n    }\r\n\r\n    subscribe(callback: (state: VState) => void): string | undefined {\r\n        if (!is(callback)) {\r\n            this.reportError(\"lib\", \"\", new IncorrectDataError(\"Callback has not been set\"))\r\n            return undefined;\r\n        }\r\n        return this.#subscriptionManager.subscribe(callback)\r\n    }\r\n\r\n    unsubscribe(id: string): boolean {\r\n        if (!is(id)) {\r\n            return false;\r\n        }\r\n        this.#subscriptionManager.unsubscribe(id);\r\n        return true;\r\n    }\r\n\r\n    getState(): VState {\r\n        return this.#copyMaker.copy(this.#state);\r\n    }\r\n\r\n    undo(): void {\r\n        this.#worker.perform({ action: UNDO_ACTION_NAME});\r\n    }\r\n    /**\r\n     * Callback invoked by a worker when state change perform is completed\r\n     * Method assigns new state and calls subscription manager to notify subscribers about the change\r\n     * @param state - new state value\r\n     * @param action - executed action\r\n     */\r\n    private onWorkerChange(state: VState, action?: BpdStateAction<PAction>) {\r\n        if (action && action.action === UNDO_ACTION_NAME) {\r\n            this.assignStateAndNotify(state, \"lib\", \"Undo from backup\");\r\n        } else {\r\n            this.#backup.push(this.#copyMaker.copy(this.#state));\r\n            this.assignStateAndNotify(state, \"action\", action ? action.action : \"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback on workerk that creates a promise that executes perfromer on passed action\r\n     * @param action action to be perfromed\r\n     */\r\n    private onWorkerPerform(action: BpdStateAction<PAction>) {\r\n        if (action && action.action === UNDO_ACTION_NAME) {\r\n            return new Promise<VState>((resolve) => {\r\n                let lastValue = this.#backup.undo();\r\n                resolve(lastValue ?? this.#copyMaker.copy(this.#state));\r\n            })\r\n        }\r\n\r\n        return new Promise<VState>((resolve) => {\r\n            resolve(this.#performer(this.#copyMaker.copy(this.#state), action));\r\n        })\r\n    }\r\n\r\n    private onWorkerError(e: Error, action?: BpdStateAction<PAction>): void {\r\n        this.reportError('action', action ? action.action : \"\", e);\r\n    }\r\n\r\n    private onSubscriberError(e: Error) {\r\n        this.reportError('lib', \"Subscribers error\", e);\r\n    }\r\n\r\n    private reportError(type: OnChangeEventType, detail: string, e: Error) {\r\n        if (this.#config && this.#config.onError) {\r\n            this.#config.onError(this.#id, type, e, detail)\r\n        }\r\n    }\r\n\r\n    private reportChange(type: OnChangeEventType, detail: string) {\r\n        if (this.#config && this.#config.onChange) {\r\n            this.#config.onChange(this.#id, type, detail, this.#state)\r\n        }\r\n    }\r\n\r\n    private assignStateAndNotify(state: VState, type: OnChangeEventType, detail: string) {\r\n        this.#state = this.#copyMaker.copy(state);\r\n        this.#subscriptionManager.notify(state)\r\n            .then((result) => {\r\n                this.reportChange(type, detail)\r\n            })\r\n            .catch(e => {\r\n                this.reportError(type, detail, e)\r\n            })\r\n    }\r\n\r\n}","import { CommonError, CreateStateError, StateManagerShorthandError } from \"./helpers/errors\";\r\nimport { is } from \"./helpers/functions\";\r\nimport { BpdStateManagerConfig, StatePerformer, BpdStateAction, BpdManagedStates } from \"./interfaces\";\r\nimport { BpdState, IBpdState } from \"./state/state\";\r\n\r\nexport const VERSION_INFO = \"0.1.1\";\r\ndeclare global {\r\n    interface Window {\r\n        $bdpStateManager: any;\r\n    }\r\n}\r\n\r\nexport class BpdStateManagerFactory<VStates, TActions> {\r\n    #config: BpdStateManagerConfig<VStates> | undefined;\r\n    #states: BpdManagedStates<VStates, TActions>;\r\n    constructor(config?: BpdStateManagerConfig<VStates>) {\r\n        this.#config = config;\r\n        this.#states = {};\r\n    }\r\n\r\n    createState(name: string, initialValue: VStates, performer: StatePerformer<TActions, VStates>, config?: BpdStateManagerConfig<VStates>) {\r\n        if (!is(name)) {\r\n            throw new CreateStateError(\"State name was not provided\");\r\n        }\r\n        this.#states[name] = new BpdState(name, initialValue, performer, config ?? this.#config);\r\n    }\r\n\r\n    removeState(name: string) {\r\n        this.executeIfValid(name, \"Perform\", (state) => {\r\n            delete this.#states[name];\r\n        })\r\n    }\r\n\r\n    getState(name: string): IBpdState<VStates, TActions> | undefined {\r\n        let resultState = undefined;\r\n        this.executeIfValid(name, \"Perform\", (state) => {\r\n            resultState = state;\r\n        })\r\n        return resultState;\r\n    }\r\n\r\n    perform(name: string, action: BpdStateAction<TActions>, callback?: (state: VStates) => void) {\r\n        this.executeIfValid(name, \"Perform\", (state) => {\r\n            state.perform(action, callback);\r\n        })\r\n    }\r\n\r\n    subscribe(name: string, callback: (state: VStates) => void): string | undefined {\r\n        let id = undefined;\r\n        this.executeIfValid(name, \"Subscribe\", (state) => {\r\n            id = state.subscribe(callback);\r\n        })\r\n        return id;\r\n    }\r\n\r\n    unsubscribe(name: string, id: string) {\r\n        this.executeIfValid(name, \"Unsubscribe\", (state) => {\r\n            state.unsubscribe(id);\r\n        })\r\n    }\r\n\r\n    undo(name: string) {\r\n        this.executeIfValid(name, \"Undo\", (state) => {\r\n            state.undo();\r\n        })\r\n    }\r\n\r\n    private executeIfValid(name: string, methodName: string, callback: (state: IBpdState<VStates, TActions>) => void) {\r\n        if (!is(name)) {\r\n            throw new CommonError(methodName + \"Error\", \"State name is not provided\")\r\n        }\r\n        let state = this.#states[name];\r\n        if (!is(state)) {\r\n            throw new CommonError(methodName + \"StateError\", \"State not found\")\r\n        }\r\n        callback(state);\r\n    }\r\n}\r\n\r\nexport class BpdStateManager {\r\n    static createStateManager<VStates, TActions>(config?: BpdStateManagerConfig<VStates>): void {\r\n        window.$bdpStateManager = new BpdStateManagerFactory<VStates, TActions>(config);\r\n    }\r\n\r\n    static createState<VStates, TActions>(name: string, initialValue: VStates, performer: StatePerformer<TActions, VStates>, config?: BpdStateManagerConfig<VStates>): void {\r\n        if (!is(window.$bdpStateManager)) {\r\n            throw new StateManagerShorthandError(\"createState\", \"Manager must be initialized first with createStateManager\")\r\n        }\r\n        window.$bdpStateManager.createState(name, initialValue, performer, config);\r\n    }\r\n\r\n    static removeState<VStates, TActions>(name: string): void {\r\n        if (!is(window.$bdpStateManager)) {\r\n            throw new StateManagerShorthandError(\"removeState\", \"Manager must be initialized first with createStateManager\")\r\n        }\r\n        window.$bdpStateManager.removeState(name);\r\n    }\r\n\r\n    static getState<VStates, TActions>(name: string): IBpdState<VStates, TActions> {\r\n        if (!is(window.$bdpStateManager)) {\r\n            throw new StateManagerShorthandError(\"getState\", \"Manager must be initialized first with createStateManager\")\r\n        }\r\n        return window.$bdpStateManager.getState(name);\r\n    }\r\n\r\n    static performStateAction<VStates, TActions>(name: string, action: BpdStateAction<TActions>, callback?: (state: VStates) => void) {\r\n        if (!is(window.$bdpStateManager)) {\r\n            throw new StateManagerShorthandError(\"perform\", \"Manager must be initialized first with createStateManager\")\r\n        }\r\n        window.$bdpStateManager.perform(name, action, callback);\r\n    }\r\n\r\n    static subscribeToState<VStates, TActions>(name: string, callback: (state: VStates) => void): string {\r\n        if (!is(window.$bdpStateManager)) {\r\n            throw new StateManagerShorthandError(\"subscribe\", \"Manager must be initialized first with createStateManager\")\r\n        }\r\n        return window.$bdpStateManager.subscribe(name, callback);\r\n    }\r\n\r\n    static unsubscribeFromState<VStates, TActions>(name: string, id: string) {\r\n        if (!is(window.$bdpStateManager)) {\r\n            throw new StateManagerShorthandError(\"unsubscribe\", \"Manager must be initialized first with createStateManager\")\r\n        }\r\n        window.$bdpStateManager.unsubscribe(name, id);\r\n    }\r\n\r\n    static undoState(name: string) {\r\n        if (!is(window.$bdpStateManager)) {\r\n            throw new StateManagerShorthandError(\"unsubscribe\", \"Manager must be initialized first with createStateManager\")\r\n        }\r\n        window.$bdpStateManager.undo(name);\r\n    }\r\n}"],"sourceRoot":""}