{"version":3,"sources":["webpack://bpdState/webpack/universalModuleDefinition","webpack://bpdState/webpack/bootstrap","webpack://bpdState/./src/helpers/functions.ts","webpack://bpdState/./src/helpers/errors.ts","webpack://bpdState/./src/helpers/backup.ts","webpack://bpdState/./src/helpers/copy.ts","webpack://bpdState/./src/subscriptions/subscriptions.ts","webpack://bpdState/./src/worker/worker.ts","webpack://bpdState/./src/state/state.ts","webpack://bpdState/./src/core.ts","webpack://bpdState/./src/hook.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","is","obj","Array","isArray","length","counter","idx","ErrorBase","Error","message","super","setPrototypeOf","this","IncorrectDataError","WorkerNotReadyError","CreateStateError","InitStateError","CommonError","type","StateManagerShorthandError","StateBackup","_states","_maxCount","v","shift","push","pop","ObjectCopyMaker","newOne","includes","id","_subscribers","_id","_counter","_onError","undefined","callback","options","subscriber","createSubscriber","subscribtionId","index","findIndex","subscirber","splice","state","toRemove","forEach","sub","singleRun","e","unsubscribe","generateId","next","_queue","_lock","_queuelock","_onPerform","_onUpdate","action","isInQueue","run","current","then","catch","data","init","mutationHandler","config","_state","_config","_mutationHandler","_worker","onUpdate","onWorkerChange","onPerform","onWorkerPerform","onError","onWorkerError","_subscriptionManager","onSubscriberError","_copyMaker","copyMaker","_backup","reportError","subscribe","perform","copy","assignStateAndNotify","Promise","resolve","lastValue","undo","detail","onChange","notify","result","reportChange","VERSION_INFO","Map","initialValue","set","executeIfValid","delete","resultState","methodName","bdpStateManagerFactory","getGlobaStateManager","createStateManager","createState","removeState","getState","performStateAction","subscribeToState","unsubscribeFromState","undoState"],"mappings":"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","file":"bpdState.hook.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpdState\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpdState\"] = factory();\n\telse\n\t\troot[\"bpdState\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","export function is(obj: any) {\r\n    if (typeof obj === 'undefined' || obj === null) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(obj) && obj.length === 0) {\r\n        return false;\r\n    }\r\n    if (typeof obj === 'string' && obj.length === 0) {\r\n        false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function* counter(): Generator<number, void, unknown> {\r\n    let idx = 0;\r\n    while (true) {\r\n        let reset = yield idx++;\r\n        if (reset || idx > 200000) {\r\n            idx = 0\r\n        }\r\n    }\r\n}","export class ErrorBase extends Error {\r\n    constructor(name: string, message?: string,) {\r\n        super(message);\r\n        Object.setPrototypeOf(this, new.target.prototype);\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport class IncorrectDataError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"IncorrectDataError\", message)\r\n    }\r\n}\r\n\r\nexport class WorkerNotReadyError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"WorkerNotReadyError\", message);\r\n    }\r\n}\r\n\r\nexport class PerformerError extends ErrorBase {\r\n    constructor(base: Error) {\r\n        super(\"PerformerError:\" + base.name, base.message);\r\n        this.stack = base.stack;\r\n    }\r\n}\r\n\r\nexport class CreateStateError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"CreateStateError\", message);\r\n    }\r\n}\r\n\r\nexport class InitStateError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"InitStateError\", message);\r\n    }\r\n}\r\n\r\nexport class CommonError extends ErrorBase {\r\n    constructor(type: string, message?: string) {\r\n        super(type, message);\r\n    }\r\n}\r\n\r\nexport class StateManagerShorthandError extends ErrorBase {\r\n    constructor(type: string, message?: string) {\r\n        super(\"StateManagerShorthandError\", type + \":\" + message);\r\n    }\r\n}","export interface IStateBackup<VState> {\r\n    push(v: VState): void;\r\n    undo(): VState | undefined;\r\n    length(): number;\r\n}\r\n\r\nexport class StateBackup<VState> implements IStateBackup<VState> {\r\n    _states: VState[];\r\n    _maxCount: number;\r\n    constructor() {\r\n        this._states = [];\r\n        this._maxCount = 20\r\n    }\r\n    push(v: VState): void {\r\n        if (this._states.length >= this._maxCount) {\r\n            this._states.shift();\r\n        }\r\n        this._states.push(v);\r\n    }\r\n    undo(): VState | undefined {\r\n        if (this._states.length > 0) {\r\n            return this._states.pop();\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    length(): number {\r\n        return this._states.length;\r\n    }\r\n\r\n}","import { IObjectCopyMaker } from \"../interfaces\";\r\n\r\nexport class ObjectCopyMaker<VState> implements IObjectCopyMaker<VState> {\r\n    copy(obj: VState): VState {\r\n        if (typeof obj === 'undefined' || obj === null) {\r\n            return obj;\r\n        }\r\n        let newOne: VState | null = null;\r\n        if (['number', 'string', 'boolean'].includes(typeof obj) || Array.isArray(obj)) {\r\n            newOne = obj;\r\n        }\r\n        else {\r\n            newOne = { ...obj };\r\n        }\r\n        return newOne;\r\n    }\r\n\r\n}","import { IncorrectDataError } from \"../helpers/errors\";\r\nimport { counter, is } from \"../helpers/functions\";\r\n\r\nexport interface Subscriber<VState> {\r\n    id: string,\r\n    options?: SubscriberOptions;\r\n    callback: (state: VState) => void;\r\n}\r\n\r\nexport interface SubscriberOptions {\r\n    singleRun: boolean;\r\n}\r\n\r\ninterface ErrorCallback {\r\n    (e: Error): void;\r\n}\r\n\r\nexport interface ISubscriptionsManager<VState> {\r\n    onError(callback: (e: Error) => void): void;\r\n    subscribe(callback: (state: VState) => void, options?: SubscriberOptions): string;\r\n    unsubscribe(subscribtionId: string): void;\r\n    notify(state: VState): Promise<boolean>;\r\n    getSubscribers(): Subscriber<VState>[];\r\n}\r\n\r\nexport class SubscriptionsManager<VState> implements ISubscriptionsManager<VState>{\r\n    private _subscribers: Subscriber<VState>[];\r\n    private _onError: ErrorCallback | undefined;\r\n    private _counter: Generator<number, void, unknown>;\r\n    private _id: string;\r\n    constructor(id: string) {\r\n        if (!is(id)) {\r\n            throw new IncorrectDataError(\"Valid Id is required\");\r\n        }\r\n        this._subscribers = [];\r\n        this._id = id;\r\n        this._counter = counter();\r\n        this._onError = undefined;\r\n    }\r\n\r\n    subscribe(callback: (state: VState) => void, options?: SubscriberOptions): string {\r\n        let subscriber = this.createSubscriber(callback, options);\r\n        this._subscribers.push(subscriber);\r\n        return subscriber.id;\r\n    }\r\n\r\n    unsubscribe(subscribtionId: string): void {\r\n        if (!is(subscribtionId)) {\r\n            return;\r\n        }\r\n        let index = this._subscribers.findIndex((subscirber: Subscriber<VState>) => {\r\n            return subscirber.id === subscribtionId;\r\n        })\r\n        if (index < 0) {\r\n            return;\r\n        }\r\n        this._subscribers.splice(index, 1);\r\n    }\r\n\r\n    async notify(state: VState): Promise<boolean> {\r\n        let toRemove: string[] = []\r\n        this._subscribers.forEach(sub => {\r\n            if (sub.options && sub.options.singleRun) {\r\n                toRemove.push(sub.id);\r\n            }\r\n            try {\r\n                sub.callback(state);\r\n            } catch (e) {\r\n                toRemove.push(sub.id);\r\n                if (this._onError) {\r\n                    this._onError(e);\r\n                }\r\n            }\r\n        })\r\n        toRemove.forEach(id => this.unsubscribe(id));\r\n        return true;\r\n    }\r\n\r\n    onError(callback: (e: Error) => void) {\r\n        this._onError = callback;\r\n    }\r\n\r\n    getSubscribers(): Subscriber<VState>[] {\r\n        return [...this._subscribers];\r\n    }\r\n\r\n    private createSubscriber(callback: (state: VState) => void, options?: SubscriberOptions): Subscriber<VState> {\r\n        return {\r\n            id: this.generateId(),\r\n            options: options,\r\n            callback: callback\r\n        }\r\n    }\r\n\r\n    private generateId(): string {\r\n        return `${this._id}:${this._counter.next().value}`;\r\n    }\r\n}","import { IncorrectDataError, WorkerNotReadyError } from \"../helpers/errors\";\r\nimport { is } from \"../helpers/functions\";\r\nimport { BpdStateAction } from \"../interfaces\";\r\n\r\nexport interface OnPerformCallback<V, P> {\r\n    (action: BpdStateAction<V>): Promise<P>;\r\n}\r\n\r\nexport interface OnUpdateCallback<V, P> {\r\n    (result: P, action?: BpdStateAction<V>): void;\r\n}\r\n\r\nexport interface OnErrorCallback<V> {\r\n    (error: Error, action?: BpdStateAction<V>): void;\r\n}\r\n\r\nexport interface IBpdStateWorker<V, P> {\r\n    perform(action: BpdStateAction<V>): void\r\n    onPerform(callback: OnPerformCallback<V, P>): void;\r\n    onUpdate(callback: OnUpdateCallback<V, P>): void;\r\n    onError(callback: OnErrorCallback<V>): void;\r\n}\r\n\r\nexport class BpdStateWorker<V, P> implements IBpdStateWorker<V, P> {\r\n    private _queue: BpdStateAction<V>[];\r\n    private _queuelock: boolean;\r\n    private _lock: boolean;\r\n    private _onPerform: OnPerformCallback<V, P> | undefined;\r\n    private _onUpdate: OnUpdateCallback<V, P> | undefined;\r\n    private _onError: OnErrorCallback<V> | undefined;\r\n    constructor() {\r\n        this._queue = [];\r\n        this._lock = false;\r\n        this._queuelock = false;\r\n        this._onError = undefined;\r\n        this._onPerform = undefined;\r\n        this._onUpdate = undefined;\r\n\r\n    }\r\n\r\n    onPerform(callback: OnPerformCallback<V, P>) {\r\n        this._onPerform = callback;\r\n    }\r\n\r\n    onUpdate(callback: OnUpdateCallback<V, P>) {\r\n        this._onUpdate = callback;\r\n    }\r\n\r\n    onError(callback: OnErrorCallback<V>) {\r\n        this._onError = callback;\r\n    }\r\n\r\n    perform(action: BpdStateAction<V>) {\r\n        if (!is(action)) {\r\n            throw new IncorrectDataError(\"Inproper action object passed to worker\")\r\n        }\r\n        if (!is(this._onPerform) || !is(this._onUpdate)) {\r\n            throw new WorkerNotReadyError(\"Callbacks are not set\");\r\n        }\r\n        if (!this.isInQueue(action)) {\r\n            this._queue.push(action);\r\n        }\r\n        this.run();\r\n    }\r\n\r\n    private run() {\r\n        if (this._queuelock || this._lock || !is(this._queue)) {\r\n            return;\r\n        }\r\n        this._lock = true;\r\n        let current = this._queue.shift();\r\n        if (!current) {\r\n            this._lock = false;\r\n            this.run();\r\n        }\r\n        if (this._onPerform && current) {\r\n            this._onPerform(current).then((state: P) => {\r\n                if (this._onUpdate) {\r\n                    this._onUpdate(state, current);\r\n                }\r\n                this._lock = false;\r\n                this.run();\r\n            }).catch(e => {\r\n                if (this._onError) {\r\n                    this._onError(e, current);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private isInQueue(action: BpdStateAction<V>) {\r\n        this._queuelock = true;\r\n        let index = this._queue.findIndex(value => {\r\n            return action.action === value.action && value.data === action.data;\r\n        })\r\n        this._queuelock = false;\r\n        return index > -1;\r\n    }\r\n}","import { IStateBackup, StateBackup } from \"../helpers/backup\";\r\nimport { ObjectCopyMaker } from \"../helpers/copy\";\r\nimport { InitStateError, IncorrectDataError } from \"../helpers/errors\";\r\nimport { is } from \"../helpers/functions\";\r\nimport { BpdStateAction, BpdStateManagerConfig, IObjectCopyMaker, OnChangeEventType, StateMutationHandler } from \"../interfaces\";\r\nimport { ISubscriptionsManager, SubscriptionsManager } from \"../subscriptions/subscriptions\";\r\nimport { IBpdStateWorker, BpdStateWorker } from \"../worker/worker\";\r\n\r\nconst UNDO_ACTION_NAME = \"$$UNDO_FROM_BACKUP\";\r\n\r\nexport interface IBpdState<VState, PAction> {\r\n    perform(action: BpdStateAction<PAction>, callback?: (state: VState) => void | undefined): void;\r\n    subscribe(callback: (state: VState) => void): string | undefined;\r\n    unsubscribe(id: string): boolean;\r\n    getState(): VState;\r\n    undo(): void;\r\n}\r\n\r\nexport class BpdState<VState, PAction> implements IBpdState<VState, PAction> {\r\n    private _state: VState;\r\n    private _backup: IStateBackup<VState>;\r\n    private _id: string;\r\n    private _config: BpdStateManagerConfig<VState>;\r\n    private _worker: IBpdStateWorker<PAction, VState>;\r\n    private _mutationHandler: StateMutationHandler<PAction, VState>;\r\n    private _subscriptionManager: ISubscriptionsManager<VState>;\r\n    private _copyMaker: IObjectCopyMaker<VState>;\r\n\r\n    constructor(id: string, init: VState, mutationHandler: StateMutationHandler<PAction, VState>, config?: BpdStateManagerConfig<VState>) {\r\n        if (!is(id)) {\r\n            throw new InitStateError(\"State id must be provided\")\r\n        }\r\n        if (!is(init)) {\r\n            throw new InitStateError(\"Initial value must be a valid, initialized object\")\r\n        }\r\n        if (!is(mutationHandler)) {\r\n            throw new InitStateError(\"Perfromer callback was not provided\")\r\n        }\r\n        this._id = id;\r\n        this._state = init;\r\n        this._config = config ?? {};\r\n        this._mutationHandler = mutationHandler;\r\n        this._worker = new BpdStateWorker<PAction, VState>();\r\n        this._worker.onUpdate(this.onWorkerChange.bind(this))\r\n        this._worker.onPerform(this.onWorkerPerform.bind(this));\r\n        this._worker.onError(this.onWorkerError.bind(this));\r\n        this._subscriptionManager = new SubscriptionsManager(this._id);\r\n        this._subscriptionManager.onError(this.onSubscriberError.bind(this));\r\n        this._copyMaker = this._config.copyMaker ?? new ObjectCopyMaker();\r\n        this._backup = new StateBackup();\r\n    }\r\n\r\n    /**\r\n     * Performs an action on the state\r\n     * @param action - action to be performed\r\n     * @param callback - optional - subscription callback for one time execution\r\n     */\r\n    perform(action: BpdStateAction<PAction>, callback?: (state: VState) => void) {\r\n        if (!is(action)) {\r\n            this.reportError(\"lib\", \"In proper action object\", new IncorrectDataError(\"In proper action object\"))\r\n        }\r\n        if (callback) {\r\n            this._subscriptionManager.subscribe(callback, {\r\n                singleRun: true\r\n            })\r\n        }\r\n        this._worker.perform(action);\r\n    }\r\n\r\n    /**\r\n     * Attaches new subscriber to state\r\n     * @param callback Function to be assigned to subscriber\r\n     */\r\n    subscribe(callback: (state: VState) => void): string | undefined {\r\n        if (!is(callback)) {\r\n            this.reportError(\"lib\", \"\", new IncorrectDataError(\"Callback has not been set\"))\r\n            return undefined;\r\n        }\r\n        return this._subscriptionManager.subscribe(callback)\r\n    }\r\n\r\n    /**\r\n     * Removes subscriber from the state\r\n     * @param id subscription identifier\r\n     */\r\n    unsubscribe(id: string): boolean {\r\n        if (!is(id)) {\r\n            return false;\r\n        }\r\n        this._subscriptionManager.unsubscribe(id);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns current state\r\n     */\r\n    getState(): VState {\r\n        return this._copyMaker.copy(this._state);\r\n    }\r\n\r\n    /**\r\n     * Performs undo on state\r\n     */\r\n    undo(): void {\r\n        this._worker.perform({ action: UNDO_ACTION_NAME });\r\n    }\r\n\r\n    /**\r\n     * Callback invoked by a worker when state change perform is completed\r\n     * Method assigns new state and calls subscription manager to notify subscribers about the change\r\n     * @param state - new state value\r\n     * @param action - executed action\r\n     */\r\n    private onWorkerChange(state: VState, action?: BpdStateAction<PAction>) {\r\n        if (action && action.action === UNDO_ACTION_NAME) {\r\n            this.assignStateAndNotify(state, \"lib\", \"Undo from backup\");\r\n        } else {\r\n            this._backup.push(this._copyMaker.copy(this._state));\r\n            this.assignStateAndNotify(state, \"action\", action ? action.action : \"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback on workerk that creates a promise that executes perfromer on passed action\r\n     * @param action action to be perfromed\r\n     */\r\n    private onWorkerPerform(action: BpdStateAction<PAction>) {\r\n        if (action && action.action === UNDO_ACTION_NAME) {\r\n            return new Promise<VState>((resolve) => {\r\n                let lastValue = this._backup.undo();\r\n                resolve(lastValue ?? this._copyMaker.copy(this._state));\r\n            })\r\n        }\r\n\r\n        return new Promise<VState>((resolve) => {\r\n            resolve(this._mutationHandler(this._copyMaker.copy(this._state), action));\r\n        })\r\n    }\r\n\r\n    private onWorkerError(e: Error, action?: BpdStateAction<PAction>): void {\r\n        this.reportError('action', action ? action.action : \"\", e);\r\n    }\r\n\r\n    private onSubscriberError(e: Error) {\r\n        this.reportError('lib', \"Subscribers error\", e);\r\n    }\r\n\r\n    private reportError(type: OnChangeEventType, detail: string, e: Error) {\r\n        if (this._config && this._config.onError) {\r\n            this._config.onError(this._id, type, e, detail)\r\n        }\r\n    }\r\n\r\n    private reportChange(type: OnChangeEventType, detail: string) {\r\n        if (this._config && this._config.onChange) {\r\n            this._config.onChange(this._id, type, detail, this._state)\r\n        }\r\n    }\r\n\r\n    private assignStateAndNotify(state: VState, type: OnChangeEventType, detail: string) {\r\n        this._state = this._copyMaker.copy(state);\r\n        this._subscriptionManager.notify(state)\r\n            .then((result) => {\r\n                this.reportChange(type, detail)\r\n            })\r\n            .catch(e => {\r\n                this.reportError(type, detail, e)\r\n            })\r\n    }\r\n\r\n}","import { CommonError, CreateStateError, StateManagerShorthandError } from \"./helpers/errors\";\r\nimport { is } from \"./helpers/functions\";\r\nimport { BpdStateManagerConfig, StateMutationHandler, BpdStateAction } from \"./interfaces\";\r\nimport { BpdState, IBpdState } from \"./state/state\";\r\n\r\nexport const VERSION_INFO = \"0.2.0\";\r\n\r\nexport class BpdStateManagerFactory<VStates, TActions> {\r\n    _config: BpdStateManagerConfig<VStates> | undefined;\r\n    _states: Map<string, IBpdState<VStates, TActions>>;\r\n    constructor(config?: BpdStateManagerConfig<VStates>) {\r\n        this._config = config;\r\n        this._states = new Map();\r\n    }\r\n\r\n    createState(name: string, initialValue: VStates, mutationHandler: StateMutationHandler<TActions, VStates>, config?: BpdStateManagerConfig<VStates>) {\r\n        if (!is(name) || is(this._states.get(name))) {\r\n            throw new CreateStateError(\"State name was not provided\");\r\n        }\r\n        this._states.set(name, new BpdState(name, initialValue, mutationHandler, config ?? this._config));\r\n    }\r\n\r\n    removeState(name: string) {\r\n        this.executeIfValid(name, \"RemoveSate\", (state) => {\r\n            this._states.delete(name);\r\n        })\r\n    }\r\n\r\n    getState(name: string): IBpdState<VStates, TActions> | undefined {\r\n        let resultState = undefined;\r\n        this.executeIfValid(name, \"GetState\", (state) => {\r\n            resultState = state;\r\n        })\r\n        return resultState;\r\n    }\r\n\r\n    perform(name: string, action: BpdStateAction<TActions>, callback?: (state: VStates) => void) {\r\n        this.executeIfValid(name, \"Perform\", (state) => {\r\n            state.perform(action, callback);\r\n        })\r\n    }\r\n\r\n    subscribe(name: string, callback: (state: VStates) => void): string | undefined {\r\n        let id = undefined;\r\n        this.executeIfValid(name, \"Subscribe\", (state) => {\r\n            id = state.subscribe(callback);\r\n        })\r\n        return id;\r\n    }\r\n\r\n    unsubscribe(name: string, id: string) {\r\n        this.executeIfValid(name, \"Unsubscribe\", (state) => {\r\n            state.unsubscribe(id);\r\n        })\r\n    }\r\n\r\n    undo(name: string) {\r\n        this.executeIfValid(name, \"Undo\", (state) => {\r\n            state.undo();\r\n        })\r\n    }\r\n\r\n    private executeIfValid(name: string, methodName: string, callback: (state: IBpdState<VStates, TActions>) => void) {\r\n        if (!is(name)) {\r\n            throw new CommonError(methodName + \"Error\", \"State name is not provided\")\r\n        }\r\n        let state = this._states.get(name);\r\n        if (!is(state)) {\r\n            throw new CommonError(methodName + \"StateError\", \"State not found\")\r\n        }\r\n        //@ts-ignore state must exists here\r\n        callback(state);\r\n    }\r\n}\r\n\r\n","import { BpdStateManagerFactory } from \"./core\";\r\nimport { StateManagerShorthandError } from \"./helpers/errors\";\r\nimport { is } from \"./helpers/functions\";\r\nimport { BpdStateManagerConfig, StateMutationHandler, BpdStateAction } from \"./interfaces\";\r\nimport { IBpdState } from \"./state/state\";\r\n\r\nlet bdpStateManagerFactory: any = undefined;\r\n\r\nfunction getGlobaStateManager<VStates, TActions>(): BpdStateManagerFactory<VStates, TActions> {\r\n    if (!is(bdpStateManagerFactory)) {\r\n        throw new StateManagerShorthandError(\"createState\", \"Manager must be initialized first with createStateManager\")\r\n    }\r\n    return bdpStateManagerFactory;\r\n}\r\n\r\nexport function createStateManager<VStates, TActions>(config?: BpdStateManagerConfig<VStates>): void {\r\n    if (is(bdpStateManagerFactory)) {\r\n        throw new StateManagerShorthandError(\"createStateManager\", \"Manager was already initialized\")\r\n    }\r\n    bdpStateManagerFactory = new BpdStateManagerFactory<VStates, TActions>(config);\r\n}\r\n\r\nexport function createState<VStates, TActions>(name: string, initialValue: VStates, mutationHandler: StateMutationHandler<TActions, VStates>, config?: BpdStateManagerConfig<VStates>): void {\r\n    getGlobaStateManager<VStates, TActions>().createState(name, initialValue, mutationHandler, config);\r\n}\r\n\r\nexport function removeState<VStates, TActions>(name: string): void {\r\n    getGlobaStateManager<VStates, TActions>().removeState(name);\r\n}\r\n\r\nexport function getState<VStates, TActions>(name: string): IBpdState<VStates, TActions> | undefined {\r\n    return getGlobaStateManager<VStates, TActions>().getState(name);\r\n}\r\n\r\nexport function performStateAction<VStates, TActions>(name: string, action: BpdStateAction<TActions>, callback?: (state: VStates) => void) {\r\n    getGlobaStateManager<VStates, TActions>().perform(name, action, callback);\r\n}\r\n\r\nexport function subscribeToState<VStates, TActions>(name: string, callback: (state: VStates) => void): string | undefined {\r\n    return getGlobaStateManager<VStates, TActions>().subscribe(name, callback);\r\n}\r\n\r\nexport function unsubscribeFromState<VStates, TActions>(name: string, id: string) {\r\n    getGlobaStateManager<VStates, TActions>().unsubscribe(name, id);\r\n}\r\n\r\nexport function undoState<VStates, TActions>(name: string) {\r\n    getGlobaStateManager<VStates, TActions>().undo(name);\r\n}"],"sourceRoot":""}